{"tagline":"Metadata APIs for Django","body":"## Contents\r\n\r\n- [Target Audience](#target-audience)\r\n- [Background](#background)\r\n- [Install](#install)\r\n- [Configure](#configure)\r\n- [Getting Started](#getting-started)\r\n    - [Bootstrap the Metadata](#bootstrap-the-metadata)\r\n- [DataField API](#datafield-api)\r\n    - [Descriptors](#descriptors)\r\n    - [Properties](#properties)\r\n    - [Aggregation](#aggregation)\r\n    - [Translators](#translators)\r\n- [DataConcept API](#dataconcept-api)\r\n    - [Introduction](#introduction)\r\n    - [Query Views](#query-views)\r\n    - [Formatters](#formatters)\r\n    - [Exporters](#exporters)\r\n- [DataContext API](#datacontext-api)\r\n    - [Condition Node](#condition-node)\r\n    - [Branch Node](#branch-node)\r\n    - [Composite Node](#composite-node)\r\n- [DataView API](#dataview-api)\r\n- [Lexicon Abstract Class](#lexicon-abstract-class)\r\n- [Management Commands](#management-commands)\r\n    - [sync](#sync)\r\n    - [orphaned](#orphaned)\r\n- [Settings](#settings)\r\n- [Optional App Integration](#optional-app-integration)\r\n- [Examples](#examples)\r\n- [Notes](#notes)\r\n\r\n## Target Audience\r\n\r\n**Developers who are interested in letting their data do the work for them.**\r\n\r\nSome experience with Django is necessary, run through the [model docs](https://docs.djangoproject.com/en/1.4/topics/db/models/) (and possibly the [tutorial](https://docs.djangoproject.com/en/1.4/intro/tutorial01/)) if you are unfamiliar with Django. Some general Python experience is necessary.\r\n\r\n## Background\r\n\r\nDjango models provides the **structural** metadata necessary for interfacing with the supported database backends. However, in general, there is no formal mechanism to supply **descriptive** or **administrative** metadata about your data model. Avocado is a Django app which provides metadata management for your models.\r\n\r\nAvocado grew out of projects being developed in a clinical research environment where data models can often be large and complex. Additionally, there are frequently data fields that contain related, but decoupled data which typically results in a large hierarchical data model.\r\n\r\nWhen developing applications that make use of such data, developers need to be able to provide end-users with appropriate context and representation of the data elements to avoid confusion and errors of omission.\r\n\r\n### A Real Example\r\n\r\nAll this abstract talk can be a bit confusing, so here is an example. In medicine, it's typical that results from a diagnostic test like a blood test might be broken into several columns in a relational database: a numerical value, units of measure, and an assessment as to whether it is normal, high, or low. As a developer you'd like to be able to bundle these conveniently in your application.\r\n\r\nWhile you could just store them all as one text field in your database, that sacrifices the ability to query and perform mathematical calculations on the numerical field. On the other hand, splitting them apart means a user who does not know your data model very well needs to know upfront to hunt down the various elements on their own, or they risk getting an incomplete picture of the retrieved data.\r\n\r\nIn many cases, these kinds of complexities result in a research workflow where the technical team act as \"keepers of the data\", and all the researcher's questions are filtered through them to be translated into queries. This situation, while good for the continued employment of engineers, is not ideal for open-ended discovery and hypothesis generation by researchers.\r\n\r\n### The Solution\r\n\r\nAvocado was designed to support the development of accessible, transparent, and data-rich applications by providing several major capabilities:\r\n\r\n- A formal means of storing additional metadata for your data model\r\n- Robust API's for interrogating metadata for dynamic query generation which includes translation, validation, cleaning and execution of queries\r\n- Built-in extensible components for the formatting and exporting of data\r\n\r\nThe power of Avocado's dynamic query generation lies in it's ability to [span relationships transparently](#relationships-are-transparent). This allows users (and to some extent developers) to focus on the data and not have to worry about the data model.\r\n\r\n### Target Applications\r\n\r\nWhile Avocado can be useful for any project, it is likely to be most applicable to projects with a heavy focus on data, especially ones with query, reporting, and export requirements and/or with medium to large data models. As a developer, it can be very useful as a tool for _accessing_ some data for the first time. For users, it is most intended for applications focused on domain-specific data discovery.\r\n\r\n### Types of Metadata\r\n\r\n#### Structural\r\n\r\nDjango's model field reference describes the options available for defining model fields. The field's subclass (e.g. `IntegerField`) and the various options passed (e.g. `null=True`) contain structural metadata which can be used to understand a field's constraints.\r\n\r\nA simple example of how this is useful is to look at how Django's field validation works. If one attempts to save an integer field with a string value, a `ValidationError` will be thrown complaining about the type. This prevents a downstream database type error.\r\n\r\nThese constraints facilitate better representation of data fields by providing more context to users. This utlimately reduces the number of assumptions and guesswork required to understand what operations can be performed on the data.\r\n\r\n#### Descriptive\r\n\r\nFor any medium to large size data model, describing and managing each field can be a painstaking task. Fields and data available to end-users for query and representation purposes should be informative. This requires high-quality, descriptive metadata.\r\n\r\nDjango provides two field options [`verbose_name`](https://docs.djangoproject.com/en/1.4/ref/models/options/#verbose-name) and [`help_text`](https://docs.djangoproject.com/en/1.4/ref/models/options/#help-text) that are descriptive metadata, but are hard-coded in the field definition. This is a limitation if the metadata is managed by another party (client or domain expert) since this must be defined in the code itself.\r\n\r\nAvocado provides numerous descriptive fields that enables better defined data fields.\r\n\r\n#### Administrative\r\n\r\nFor applications which integrate multiple data sources, it can be useful to keep track of the various source information such as the data's organization, a Uniform Resource Identifier (URI), and access permissions.\r\n\r\nAvocado has support for Django's built-in [sites](https://docs.djangoproject.com/en/1.4/ref/contrib/sites/) and [auth](https://docs.djangoproject.com/en/1.4/topics/auth/#permissions) apps enabling course grain (per-site/deployment) and fine grain (per-user) permissions on viewing and modifying data fields.\r\n\r\n---\r\n\r\n## Prerequisites\r\n\r\nAs of now, Python 2.7 is required. Want older versions supported? Fork the repo and submit a pull request.\r\n\r\nTo install Avocado and it's dependencies, it is assumed you have the latest versions of [distribute](http://pypi.python.org/pypi/distribute) (or [setuptools](http://pypi.python.org/pypi/setuptools)) and [Pip](http://pypi.python.org/pypi/pip) installed.\r\n\r\n## Install\r\n\r\n```\r\npip install avocado\r\n```\r\n\r\nThe _hard_ dependencies which will auto-install are [Django 1.4+](https://www.djangoproject.com), [modeltree 1.0+](http://pypi.python.org/pypi/modeltree) and [django-jsonfield 0.9+](https://github.com/bradjasper/django-jsonfield/).\r\n\r\n## Optional Dependencies\r\n\r\nFor a bare-bones Avocado installation the following dependencies may be skipped, but peruse through to understand the purpose of each one listed.\r\n\r\n_Have a suggestion for additional metadata integration? [File an issue](https://github.com/cbmi/avocado/issues/new) on Avocado's GitHub repo._\r\n\r\n#### [Django \"sites\" Framework](https://docs.djangoproject.com/en/1.4/ref/contrib/sites/)\r\nHaving this installed enables associating `DataField`s and/or `DataConcept`s to specific sites, or more specifically, deployments. For example, an internal and external deployment may exist for the same application, but only the internal deployment provides access to certain _restricted_ fields for operational use.\r\n\r\nInstall by adding `django.contrib.sites` to `INSTALLED_APPS`.\r\n\r\n#### [django-guardian](http://packages.python.org/django-guardian/)\r\nThis enables fine-grain control over who has permissions for various `DataField`s. Permissions can be defined at a user or _group_ level.\r\n\r\nInstall by doing `pip install django-guardian` and adding `guardian` to `INSTALLED_APPS`.\r\n\r\n#### [django-haystack](http://haystacksearch.org)\r\nWhat's having all this great descriptive data if no one can find it? Haystack provides search engine facilities for the metadata.\r\n\r\nInstall by doing `pip install django-haystack` and installing one of the supported search engine backends. The easiest to setup is [Whoosh](http://pypi.python.org/pypi/Whoosh) which is implemented in pure Python. Install it by doing `pip install whoosh`. Add `haystack` to `INSTALLED_APPS`.\r\n\r\n#### [SciPy](http://www.scipy.org)\r\nAvocado comes with a `stats` package for performing some rudimentary statistical, aggregation and clustering operations on the data. This is not always required or necessary for all data, but if there is a heavy emphasis on numerical data or the amount of data is quite large, the `stats` may come in handy.\r\n\r\nInstall by doing `pip install numpy` first (a dependency of SciPy), followed by `pip install scipy`. Note, there are a few dependencies for compilation, so review [SciPy's installation instructions](http://www.scipy.org/Installing_SciPy) for more details.\r\n\r\n#### [openpyxl](http://packages.python.org/openpyxl/)\r\nAvocado comes with an `export` package for supporting various means of exporting data into different formats. One of those formats is the native Microsoft Excel _.xlsx_ format. To support that, the openpyxl library is used.\r\n\r\nInstall by doing `pip install openpyxl`.\r\n\r\n## Configure\r\n\r\nAt a minimum, your `INSTALLED_APPS` should contain the following apps:\r\n\r\n```python\r\nINSTALLED_APPS = (\r\n    'django.contrib.admin',\r\n    'django.contrib.auth',\r\n    'django.contrib.contenttypes',\r\n    'django.contrib.messages',\r\n    'django.contrib.sessions',\r\n    'django.contrib.sites',\r\n\r\n    'avocado',\r\n    ...\r\n)\r\n```\r\n\r\n---\r\n\r\n## Getting Started\r\n\r\nTo introduce the API gradually and coherently, we are going to start with two example models, `Author` and `Book` in an app named `library`.\r\n\r\n```python\r\n# library/models.py\r\nclass Author(models.Model):\r\n    name = models.CharField(max_length=100)\r\n\r\nclass Book(models.Model):\r\n    title = models.CharField(max_length=100)\r\n    author = models.ForeignKey(Author)\r\n    pub_date = models.DateField('publication date', null=True)\r\n```\r\n\r\n### Bootstrap the Metadata\r\n\r\nTo reiterate the introduction above, Avocado is about putting in place ways to define and make use of metadata surrounding your data model.\r\n\r\nAvocado comes with a `sync` subcommand which introspects Django models and creates `DataField` instances representing the model fields. At least one app label (`library`) or model label (`library.book`) must be specified.\r\n\r\nBy default, `DataField` instances are not created for primary and foreign key fields. In practice, surrogate key fields are used infrequently as is, thus they are not created by default. To override this behavior and include key fields, add the flag `--include-keys`.\r\n\r\nLikewise, model fields may be marked as not being editable in the model field definitions. This flag is turned on typically for operational or bookkeeping fields such as timestamps. By default, `DataField`s are not created for these either, but can overridden by passing the `--include-non-editable`.\r\n\r\n```bash\r\n./manage.py avocado sync library\r\n1 field added for Author\r\n2 fields added for Book\r\n```\r\n\r\nOn a side note, the `avocado` command acts as a parent for various subcommands. Simply type `./manage.py avocado` to show a list of available subcommands.\r\n\r\n### DataField API\r\n\r\nAn Avocado `DataField` instance represents a single Django model field instance. These three attributes uniquely identify a model field.\r\n\r\n- `f.field_name` - The name of the field on the model\r\n- `f.model_name` - The name of the model this field is defined for\r\n- `f.app_name` - The name of the app this field's model is defined in\r\n\r\n```python\r\n>>> from avocado.models import DataField\r\n>>> f = DataField(field_name='title', model_name='book', app_name='library')\r\n>>> f\r\n<DataField 'library.book.title'>\r\n```\r\n\r\nThese three attributes enable referencing to the actual field instance and model class:\r\n\r\n- `f.field` - The model DataField instance this field represents\r\n- `f.model` - The model class this field is associated with\r\n\r\n```python\r\n>>> f.field\r\n<django.db.models.fields.CharField at 0x101b5fe10>\r\n>>> f.model\r\n<class 'library.models.Book'>\r\n```\r\n\r\n#### Descriptors\r\n\r\nAdditional metadata can be defined for this object to make it more useful to humans. Define various _descriptors_ to enhance the meaning of a data field.\r\n\r\n- `f.name` - A verbose human readable name of the field\r\n- `f.name_plural` - The plural form of the verbose name. If not defined, an _s_ will be appended to `f.name` when the plural form is accessed.\r\n- `f.description` - A long description for the field\r\n- `f.keywords` - Other related keywords (this is primarily applicable for search indexing by [django-haystack](#django-haystack))\r\n- `f.unit` - The unit of the data, for example _gram_\r\n- `f.unit_plural` - The plural form of the unit, for example _grams_. If not defined, an _s_ will be appended to `f.unit` when the plural form is accessed.\r\n\r\n```python\r\n>>> f.name = 'Price'\r\n# f.name_plural can be set, but does not need to be since\r\n# this is a simple plural form\r\n>>> f.get_plural_name()\r\n'Prices'\r\n# likewise with the f.unit_plural..\r\n>>> f.unit = 'dollar'\r\n>>> f.get_plural_unit()\r\n'dollars'\r\n```\r\n\r\n#### Properties\r\n\r\n`DataField`s also acts as an interface and exposes various properties and methods for directly accessing the underlying data or properties about the data.\r\n\r\n##### Editable\r\n\r\n- `f.enumerable` - A flag denoting if the field's data is composed of an enumerable set. During a [sync](avocado-sync), each field's data is evaluated based on the internal type and the size of the data (number of distinct values). By default, if the field is a `CharField` and has `SYNC_ENUMERABLE_MAXIMUM` or less distinct values, this will be set to `True`. \r\n- `f.searchlable` - A flag denoting if the field's data should be treated as searchable text. This applies to `TextField`s and `CharField`s which don't meet the requirements for being `enumerable`.\r\n\r\n##### Read-only\r\n\r\n- `f.internal_type` - The low-level datatype of the field. This is really only used for mapping to the below `simple_type`. Read more about the [internal vs. simple types](#internal-vs-simple-types).\r\n- `f.simple_type` - The high-level datatype of the field used for validation purposes and as general metadata for client applications. (These types can be overridden, [read about](SIMPLE_TYPE_MAP) the `SIMPLE_TYPE_MAP` setting)\r\n- `f.size` - Returns the number of _distinct_ values for this field\r\n- `f.values` - Returns a tuple of distinct raw values ordered by the field. If the corresponding model is a subclass of Avocado's `Lexicon` abstract model, the order corresponds to the `order` field on the `Lexicon` model subclass. Read more about the [`Lexicon` abstract class](#lexicon-abstract-class).\r\n- `f.labels` - Returns a unicoded tuple of labels. If the corresponding model is a subclass of Avocado's `Lexicon` abstract model, this corresponds to the `label` field on the `Lexicon` model subclass. Read more about the [`Lexicon` abstract class](#lexicon-abstract-class).\r\n- `f.choices` - A tuple of pairs zipped from `f.values` and `f.labels`. This is useful for populating form fields for client applications.\r\n- `f.query()` - Returns a `ValuesQuerySet` for this field. This is equivalent to `f.model.objects.values(f.field_name)`.\r\n\r\n```python\r\n>>> f.internal_type\r\n'char'\r\n>>> f.simple_type\r\n'string'\r\n>>> f.size\r\n33\r\n>>> f.values\r\n('A Christmas Carol', 'A Tale of Two Cities', 'The Adventures of Oliver Twist', ...)\r\n>>> f.labels\r\n(u'A Christmas Carol', u'A Tale of Two Cities', u'The Adventures of Oliver Twist', ...)\r\n>>> f.choices\r\n(('A Christmas Carol', u'A Christmas Carol'), ...)\r\n>>> f.query()\r\n[{'title': 'A Christmas Carol'}, ...]\r\n```\r\n\r\n#### Aggregation\r\n\r\nA simple, yet powerful set of methods are available for performing aggregations. Each method below returns an `Aggregator` object which enables chaining aggregations together as well as adding conditions to filter or exclude results.\r\n\r\nBy default, aggregations are table-wide. Zero or more lookups can be supplied to perform the aggregation relative to the fields in the `GROUP BY`.\r\n\r\n- `f.count([*groupby], distinct=False)` - Returns a count of all values for the field. If `distinct` is `True`, a `COUNT(DISTINCT foo)` will be performed.\r\n- `f.max([*groupby])` - Returns the max value\r\n- `f.min([*groupby])` - Returns the min value\r\n- `f.avg([*groupby])` - Returns the average of all values\r\n- `f.sum([*groupby])` - Returns the sum of all values\r\n- `f.stddev([*groupby])` - Returns the standard deviation of all values. _This is not supported in SQLite by default._\r\n- `f.variance([*groupby])` - Returns the variance of all values. _This is not supported in SQLite by default._\r\n\r\nTable-wide aggregations:\r\n\r\n```python\r\n>>> price = DataField.objects.get_by_natural_key('library', 'book', 'price')\r\n>>> price.count()\r\n33\r\n>>> price.max()\r\n132.00\r\n>>> price.min()\r\n14.50\r\n>>> price.avg()\r\n32.25\r\n>>> price.sum()\r\n1064.25\r\n```\r\n\r\nEach aggregation method can take Avocado or standard QuerySet lookup strings to group by those fields.\r\n\r\n```python\r\n>>> price.count('book__author')\r\n[{'author': 'Charles Dickens', 'count': 4}, ...]\r\n>>> price.avg('book__author')\r\n[{'author': 'Charles Dickens', 'avg': 50.45}, ...]\r\n```\r\n\r\nThe methods are chainable, the only caveat is that the `*groupby` arguments must be the same across all the aggregation methods. To bypass this, use the `groupby()` method to affix the group by fields.\r\n\r\n```python\r\n>>> price.count().avg().sum()\r\n{'count': 33, 'avg': 32.25, 'sum': 1064.25}\r\n>>> price.groupby('book__author').count().avg().sum()\r\n[{'author': 'Charles Dickens', 'count': 4, 'avg': 50.45, 'sum': 201.80}, ...]\r\n```\r\n\r\nAdditional methods are available for filtering, excluding and ordering the data. Each aggregation that is chained is named after the aggregation applied. As shown below, the count aggregation can be used in the subsequent `filter` and `order_by` methods.\r\n\r\n```python\r\n>>> price.count('book__author').filter(count__gt=50).order_by('count')\r\n```\r\n\r\n### Translators\r\n\r\nTranslators are used to modify query conditions prior to being executed. Depending on the quality or variability of your data, the query interface for a field may not represent the data 1:1 with the underlying data. Thus the incoming query condition may need to be translated in some way to work with the underlying database.\r\n\r\n\r\n\r\nThese operator classes perform only light validation of the value to prevent being too restrictive.\r\n\r\n```python\r\n>>> from avocado.query.operators import registry as operators\r\n>>> iexact = operators.get('iexact')\r\n>>> iexact.is_valid(['hello', 'world'])\r\nFalse\r\n>>> iexact.is_valid('hello world')\r\nTrue\r\n>>> inlist = operators.get('inlist')\r\n>>> inlist.is_valid(['hello', 'world'])\r\nTrue\r\n>>> inlist.is_valid('hello world')\r\nFalse\r\n```\r\n\r\nThe base `Translator` class uses [Django's Form API](https://docs.djangoproject.com/en/1.4/ref/contrib/forms/api/) to validate and clean the value relative to the underlying model field (e.g. `f.field`).\r\n\r\nThe primary method to call is `translate` which calls `clean_value` and `clean_operator`.\r\n\r\n```python\r\n>>> t = Translator()\r\n>>> t.translate(f, 'icontains', 'Python')\r\n{\r\n    'condition': <django.db.query_utils.Q at 0x1027b78d0>,\r\n    'annotations': {},\r\n    'cleaned_data': {\r\n        'operator': 'icontains',\r\n        'value': u'Python',\r\n    },\r\n    'raw_data': {\r\n        'operator': 'icontains',\r\n        'value': 'Python',\r\n    },\r\n}\r\n```\r\n\r\n## DataConcept API\r\n\r\n### Introduction\r\n\r\nAs much as Avocado is a metadata management tool, a prime consumer of this metadata are humans. More specifically, the metadata can be used to provide more context and meaning to the data and the data model.\r\n\r\nThe notion of a `DataConcept` came from the need to represent discrete data in a human-readable domain-specific way. Data is typically stored in a normalized, discrete and efficient way, thus rendering it a bit obscure in it's raw state. Sometimes a single _column_ of data in database table is meaningless without another column, for example a column of `weight` without the column of `unit`.\r\n\r\nOf course, data must be stored in this discrete way to ensure the database can treat it properly and perform the correct operations on that data. Unfortunately, humans don't care about how data is stored, nor should they. **They simply want the data to be accessible so they can consume it in a way that makes sense to them.**\r\n\r\nConcepts encapsulate one or more fields intended to be represented together in some way. This sounds very abstract and is intentionally so. This lightweight abstract encourages being creative in how fields are represented together.\r\n\r\n### Query Views\r\n\r\n#### Datatypes\r\n\r\nDatatypes, in the context of Avocado, are used for representation of the data for querying, not for data entry. Differentiating between datatypes such as `int` vs. `float` are typically too specific for data discovery, thus these related native types are rolled up into a high-level datatype, such as `number`.\r\n\r\n- `string`\r\n- `number`\r\n- `date`\r\n- `boolean`\r\n\r\n### Formatters\r\n\r\nThe most common utility of the DataConcept abstraction is formatting the fields' data in a usable format for the consumer. The consumer may be a human, a Web browser, an R interpreter or anything else. Regardless of the consume, formatters provide an API for taking in raw data and outputting a representation of that data.\r\n\r\nThe most common utility of the `DataConcept` abstraction is formatting the fields' data in a usable format for the consumer. The consumer may be a human, a Web browser, an R interpreter or anything else. Regardless of the consume, formatters provide an API for taking in raw data and outputting a representation of that data.\r\n\r\n```python\r\nfrom avocado.formatters import Formatter\r\n# Get the 'Dosage' concept which combines the 'dose'\r\n# and 'unit' fields\r\ndosage = DataConcept.objects.get(name='Dosage')\r\n# Prepare a formatter for the dosage concept\r\nformatter = Formatter(dosage)\r\nvalues = [60, 'mg', 'as needed']\r\n# Returns ['60', 'mg', 'as needed']\r\nformatter(values, preferred_formats=['string'])\r\n```\r\n\r\nA formatter attempts to solve two problems. First, **coerce the various values into the preferred format** and secondly, perform an operation on each or all of the values. As shown above, the `formatter` instance is callable and takes a sequence of `values` and a `preferred_formats` argument. Since this is the base formatter class, aside from being good at coercing datatypes, it is not terribly useful.\r\n\r\nFormatters can be easily created by subclassing the base `Formatter` class and adding, overriding, or augmenting the methods. As stated above, a formatter can be applied each raw value or all values together. As an example of this, we can create a simple `ConcatFormatter`.\r\n\r\n```python\r\nclass ConcatFormatter(Formatter):\r\n    def to_string(self, values, cfields, **context):\r\n        joined = ' '.join(map(lambda x: super(ConcatFormatter, self).to_string(x),\r\n                values.values()))\r\n        return OrderedDict({'output': joined})\r\n\r\n    # Informs the class this method can process multiple values at a time\r\n    to_string.process_multiple = True\r\n```\r\n\r\n### Exporters\r\n\r\n---\r\n\r\n## DataContext API\r\n\r\nAvocado defines a simple structure for representing query conditions. A query condition boils down to three components:\r\n\r\n- the `datafield` to which the condition applies\r\n- the `operator` which defines how the condition is being applied\r\n- the `value` which defines which value(s) are affected by the condition\r\n\r\nJust as in a SQL statement, applying conditions to query enables constraining the data to some subset. Conditions can of course be combined using conditional AND or OR operators (not the same operators mentioned above). These conditional _branches_ join together two or more conditions or other branches resulting in a _tree_ of conditions.\r\n\r\n```\r\n     AND\r\n    /   \\\r\n  OR     A\r\n /  \\\r\nB    C\r\n```\r\n\r\nUsing `datafield`s as the condition's reference point enables applying the tree of conditions to any query.\r\n\r\nThe `DataContext` model provides a simple API for storing, persisting and applying the condition tree. In it's raw state, the condition tree is simply a combination of _condition_ and _branch_ nodes. Following this example, the schema of both node types are described.\r\n\r\n```python\r\n>>> from avocado.models import DataContext\r\n>>> cxt = DataContext()\r\n# This will be serialized (and validated) to JSON when saved\r\n>>> cxt.json = {'id': 'library.book.price', 'operator': 'gt', 'value': 10.00}\r\n>>> queryset = cxt.apply()\r\n>>> print str(queryset.query)\r\n'SELECT \"book\".\"id\", \"book\".\"title\", \"book\".\"author_id\", \"book\".\"price\" FROM \"book\" WHERE \"book\".\"price\" > 10.00 '\r\n```\r\n\r\n#### Condition Node\r\n\r\n- `id` - The value can be:\r\n    - An `int` representing the primary key identifer for a `DataField` instance, e.g. `1`\r\n    - Period-delimited `string` representing a natural key for a `DataField` instance, e.g. `'app.model.field'`\r\n    - An `array` of strings representing a natural key for a `DataField` instance, e.g. `[\"app\", \"model\", \"field\"]`\r\n- `operator` - A `string` representing a valid `DataField` operator. Valid operators vary depending on the implementation and are validated downstream. If not specified, the operator defaults to `exact`.\r\n- `value` - Any valid JSON data type.\r\n\r\n#### Branch Node\r\n\r\n- `type` - A `string` that is `\"and\"` or `\"or\"` representing the type of branch or logical operation between child nodes defined in the `children` property.\r\n- `children` - An `array` of _two_ or more nodes.\r\n    - _See example [DataContext Condition Trees]_\r\n\r\n---\r\n\r\n## DataView API\r\n\r\n---\r\n\r\n## Lexicon Abstract Class\r\n\r\nAvocado defines an abstract class named `Lexicon`. It is a common practice\r\nwhen normalizing a data model to _break out_ repeated finite sets of terms\r\nwithin a column into their own table. This is quite obvious for entities such\r\nas _books_ and _authors_, but less so for commonly used or enumerable\r\nterms.\r\n\r\n```\r\nid | name | birth_month\r\n---+------+------------\r\n 1   Sue    May\r\n 2   Joe    June\r\n 3   Bo     Jan\r\n 4   Jane   Apr\r\n...\r\n```\r\n\r\nThe above shows a table with three columns `id`, `name` and `birth_month`.\r\nThere are some inherent issues with `birth_month`:\r\n\r\n1. Months have an arbitrary order which makes it very difficult to order the\r\nrows by `birth_month` since they are ordered lexicographically\r\n2. As the table grows (think millions) the few bytes of disk space each\r\nrepeated string takes up starts having a significant impact\r\n3. The cost of querying for the distinct months within the population gets\r\nincreasingly more expensive as the table grows\r\n4. As the table grows, the cost of table scans increases since queries are\r\nacting on strings rather than an integer (via a foreign key)\r\n\r\nAlthough the above example is somewhat contrived, the reasons behind this\r\ntype of normalization are apparent.\r\n\r\nTo implement, subclass and define the `value` and `label` fields.\r\n\r\n```python\r\nfrom avocado.lexicon.models import Lexicon\r\n\r\nclass Month(Lexicon):\r\n    label = models.CharField(max_length=20)\r\n    value = models.CharField(max_length=20)\r\n```\r\n\r\nA few of the advantages include:\r\n\r\n- define an arbitrary `order` of the items in the lexicon\r\n- define a integer `code` which is useful for downstream clients that\r\nprefer working with a enumerable set of values such as SAS or R\r\n- define a verbose/more readable label for each item\r\n    - For example map _Jan_ to _January_\r\n\r\nIn addition, Avocado treats Lexicon subclasses specially since it is such a\r\ncommon practice to use them. They are used in the following ways:\r\n\r\n- performing a `sync` will ignore the `label`, `code`, and `order`\r\nfields since they are supplementary to the `value` (you can of course add them\r\nmanually later)\r\n- the `DataField` that represents the `value` field on a Lexicon subclass will\r\n    - use the `order` field whenever accessing values or when applied to a query\r\n    - use the `label` field when accessing `f.labels`\r\n    - use the `code` field when accessing `f.codes`\r\n\r\n---\r\n\r\n## Management Commands\r\n\r\nAvocado commands are namespaced under `avocado`. Execute `./bin/manage.py avocado` to view a list of available subcommands.\r\n\r\n### sync\r\n\r\nThe sync command creates DataField instances from Djang model fields. This will be used whenever new models or new fields are added to your data model.\r\n\r\n```bash\r\n./manage.py avocado sync labels [--update] [--include-keys] [--include-non-editable]\r\n```\r\n\r\n#### Parameters\r\n\r\n- `labels` - refers to one or more space-separated app, model or field labels, for example library.book refers the the model Book in the app library.\r\n- `--update` - updates existing field instances (relative to the apps or models defined and overwrites any existing descriptive values such as name, name_plural, and description.\r\n- `--include-non-editable` - creates field instance for model fields with editable=False (by default these are ignored).\r\n- `--include-keys` - creates fields instances for primary and foreign key fields (by default these are ignored).\r\n\r\n### orphaned\r\n\r\nChecks for DataField instances that no longer map to Django model fields (like a dead hyperlink).\r\n\r\n```bash\r\n./manage.py avocado orphaned [--unpublish]\r\n```\r\n\r\n#### Parameters\r\n\r\n`--unpublish` - unpublishes all fields found to be orphaned.\r\n\r\n\r\n### data\r\n\r\nFinds all models referenced by the app or model ``labels`` and updates data-related properties such as caches and pre-calculated values.\r\n\r\n```bash\r\n./manage.py avocado data labels [--modified]\r\n```\r\n\r\n#### Parameters\r\n\r\n- `labels` - refers to one or more space-separated app, model, or field labels, for example library.book refers the the model Book in the app library.\r\n- `--modified` - Updates the `data_modified` on `DataField` instances corresponding the labels. This is primarily used for cache invalidation.\r\n\r\n**Note, currently `--modified` is the only flag that does anything**\r\n\r\n### cache\r\n\r\nFinds all models referenced by the app, model or field `labels` and explicitly updates various cached properties relative to the `data_modified` on `DataField` instances.\r\n\r\n## Settings\r\n\r\nAvocado settings are defined as a dictionary, named `AVOCADO`, with each key corresponding to a setting listed below:\r\n\r\n```python\r\nAVOCADO = {\r\n    'SIMPLE_TYPE_MAP': { ... },\r\n    'SYNC_ENUMERABLE_MAXIMUM': 50,\r\n    ...\r\n}\r\n```\r\n\r\n### SIMPLE_TYPE_MAP\r\n\r\n`DataField` datatypes from Avocado's perspective are used purely as metadata for the purposes of making the underlying data accessible.\r\n\r\nThis setting is used to customize what is returned by the `f.datatype` property. The default datatype comes from the internal datatype of a the model field's `get_internal_type()` method. Any of these default datatypes can be mapped to some other datatype.\r\n\r\nDatatypes in this context should be simple, for example not differentiating between `int`, `float`, or `Decimal`. They are all just numbers, to that is the datatype.\r\n\r\nThese datatypes help define how input is validated and which operators are allowed.\r\n\r\nThe default map:\r\n\r\n```\r\n# A mapping between model field internal datatypes and sensible\r\n# client-friendly datatypes. In virtually all cases, client programs\r\n# only need to differentiate between high-level types like number, string,\r\n# and boolean. More granular separation be may desired to alter the\r\n# allowed operators or may infer a different client-side representation\r\nSIMPLE_TYPE_MAP = {\r\n    'auto': 'number',\r\n    'biginteger': 'number',\r\n    'decimal': 'number',\r\n    'float': 'number',\r\n    'integer': 'number',\r\n    'positiveinteger': 'number',\r\n    'positivesmallinteger': 'number',\r\n    'smallinteger': 'number',\r\n\r\n    'nullboolean': 'boolean',\r\n\r\n    'char': 'string',\r\n    'email': 'string',\r\n    'file': 'string',\r\n    'filepath': 'string',\r\n    'image': 'string',\r\n    'ipaddress': 'string',\r\n    'slug': 'string',\r\n    'text': 'string',\r\n    'url': 'string',\r\n}\r\n```\r\n\r\n### OPERATOR_MAP\r\n\r\n```\r\n# A mapping between the client-friendly datatypes and sensible operators\r\n# that will be used to validate a query condition. In many cases, these types\r\n# support more operators than what are defined, but are not include because\r\n# they are not commonly used.\r\nOPERATOR_MAP = {\r\n    'boolean': ('exact', '-exact', 'in', '-in'),\r\n    'date': ('exact', '-exact', 'in', '-in', 'lt', 'lte', 'gt', 'gte', 'range'),\r\n    'number': ('exact', '-exact', 'in', '-in', 'lt', 'lte', 'gt', 'gte', 'range'),\r\n    'string': ('exact', '-exact', 'iexact', '-iexact', 'in', '-in', 'icontains', '-icontains'),\r\n    'datetime': ('exact', '-exact', 'in', '-in', 'lt', 'lte', 'gt', 'gte', 'range'),\r\n    'time': ('exact', '-exact', 'in', '-in', 'lt', 'lte', 'gt', 'gte', 'range'),\r\n}\r\n```\r\n\r\n### INTERNAL_TYPE_FORMFIELDS\r\n\r\n```\r\n# A general mapping of formfield overrides for all subclasses. the mapping is\r\n# similar to the SIMPLE_TYPE_MAP, but the values reference internal\r\n# formfield classes, that is integer -> IntegerField. in many cases, the\r\n# validation performed may need to be a bit less restrictive than what the\r\n# is actually necessary\r\nINTERNAL_TYPE_FORMFIELDS = {\r\n    'auto': 'IntegerField',\r\n    'integer': 'FloatField',\r\n    'positiveinteger': 'FloatField',\r\n    'positivesmallinteger': 'FloatField',\r\n    'smallinteger': 'FloatField',\r\n\r\n    # Generic datatypes mapped from above\r\n    'number': 'FloatField',\r\n}\r\n```\r\n\r\n### SYNC_ENUMERABLE_MAXIMUM\r\n\r\n```\r\n# The maximum number of distinct values allowed for setting the\r\n# `enumerable` flag on `DataField` instances during the `sync` process. This\r\n# will only be applied to fields with non-text strings types and booleans\r\nSYNC_ENUMERABLE_MAXIMUM = 30\r\n```\r\n\r\n---\r\n\r\n# Optional App Integration\r\n\r\n## [South](http://south.aeracode.org/)\r\nDjango's de facto app for creating and managing database migrations. 'nuff said.\r\n\r\n## [django-haystack](http://haystacksearch.org/)\r\nAvocado utilizes Haystack for building search indexes for `DataField` and `DataConcept` objects and their underlying data. In practice, this is primarily used for clients exposing a search feature for finding the `DataField` or `DataConcept` representations for some data.\r\n\r\n## [django-activity-stream](http://justquick.github.com/django-activity-stream/)\r\nAvocado is about supporing data discovery and iteration by providing APIs for rapidly implementing interfaces, enabling this workflow. Many of our in-house applications have made good use of tracking users' own discovery and iteration progress. In practice, this acts as a history/log of a user's discovery workflow. This can be useful for users and developers alike.\r\n\r\nIf this app is installed, changes to `DataContext` and `Query` objects will trigger actions to be sent to the respective user's stream.\r\n\r\n## [Numpy](http://numpy.scipy.org/) & [SciPy](http://www.scipy.org/)\r\n\r\nAvocado has support for clustering continuous numeric values when generating distribution queries.\r\n\r\n---\r\n\r\n## Examples\r\n\r\n### DataContext Condition Trees\r\n\r\n#### Single Condition\r\n\r\n```javascript\r\n{\r\n    \"id\": 2,\r\n    \"operator\": \"iexact\",\r\n    \"value\": 50\r\n}\r\n```\r\n\r\n#### Branch with Two Conditions\r\n\r\n```javascript\r\n{\r\n    \"type\": \"and\",\r\n    \"children\": [{\r\n        \"id\": 2,\r\n        \"operator\": \"iexact\",\r\n        \"value\": 50\r\n    }, {\r\n        \"id\": 1,\r\n        \"operator\": \"in\",\r\n        \"value\": [\"foo\", \"bar\"]\r\n    }\r\n}\r\n```\r\n\r\n#### Branch with One Condition and One Branch\r\n\r\n```javascript\r\n{\r\n    \"type\": \"or\",\r\n    \"children\": [{\r\n        \"id\": 2,\r\n        \"operator\": \"iexact\",\r\n        \"value\": 50\r\n    }, {\r\n        \"type\": \"and\",\r\n        \"children\": [{\r\n            \"id\": 1,\r\n            \"operator\": \"in\",\r\n            \"value\": [\"foo\", \"bar\"]\r\n        }, {\r\n            \"id\": 1,\r\n            \"operator\": \"in\",\r\n            \"value\": [\"baz\", \"qux\"]\r\n        }]\r\n    }]\r\n}\r\n```\r\n\r\n## Notes\r\n\r\n### Internal vs. Simple Types\r\n\r\nInternal types correspond to the model field's class and are necessary when performing write operations for data intregrity. For query purposes, internal types tend to be too _low-level_ and restrictive during query validation. To provide a less restrictive interface for query validation, Avocado introduces a _simple_ type which merely maps internal types to a higher-level type such as _string_ or _number_.\r\n\r\n### Relationships Are Transparent\r\n\r\nAvocado uses the [ModelTree](https://github.com/cbmi/modeltree) API to build in-memory indexes for each model accessed by the application. To build an index, all possible paths from the given _root_ model are traversed and metadata about each relationship is captured. When a query needs to be generated, the lookup string can be generated for a model field relative to the root model.\r\n\r\n```python\r\n>>> tree = ModelTree(Author)\r\n>>> title = Book._meta.get_field_by_name('title')\r\n>>> tree.query_string_for_field(title, 'icontains')\r\n'book__title__icontains'\r\n```\r\n\r\nThis looks a bit clumsy in practice which is why Avocado uses the `DataField` class to manage all this field-specific _stuff_.\r\n\r\nHaving these indexes enables generating queries regardless of the entry point and which fields are being queried or retrieved. This perceivably _flattens_ out the data model from the client's perspective which increases it's accessiblity.","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Avocado","google":"UA-30792817-2"}